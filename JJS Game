--!strict
-- ModuleScript: HybridModule (strict, nil-safe, fully typed, single file)
-- AI GENERATING MEMES UNTIL I BECOME A GAZILLIONAIRE (LIKE, COMMENT, REPOST, SHARE) FOR MORE MEMES. COMMENT IDEAS U WANT TO SEE!

--[[
	[ARCHITECTURAL OVERVIEW]
	1. TYPE DEFINITIONS: Robust Luau typing for all subsystems.
	2. MATH LIBRARY: Custom easing, Bezier, and lightning generation.
	3. HANDLER: Core state management for the custom character.
	4. PHYSICS: Capsule-cast based movement (WallRun/Climb/Dash).
	5. ANIMATION: Procedural sway, IK, and state-based blending.
	6. COMBAT: Deepwoken-inspired parry/posture and auto-aim projectiles.
	7. DESTRUCTION: Shatter logic for environmental interaction.
	8. VFX: Lightning and Bezier trail generation.
	9. UI: Responsive bar and skill slot management.
	10. INPUT: Unified ContextAction and UserInput handler.
]]

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")
local Debris = game:GetService("Debris")

--// Types & Interfaces
export type PhysicsSettings = {
	Gravity: Vector3,
	MaxSlope: number,
	GroundFriction: number,
	AirFriction: number,
	StepHeight: number,
	WalkAccel: number,
	AirAccel: number,
	JumpPower: number,
	DashSpeed: number,
	DashTime: number,
	ClimbSpeed: number,
	WallRunSpeed: number,
}
export type AnimationSettings = {
	BlendSharpness: number,
	SwayAmplitude: number,
	SwayFrequency: number,
	FootIK: boolean,
}
export type CombatSettings = {
	ParryWindow: number,
	ParryCooldown: number,
	PostureMax: number,
	PostureRegen: number,
	GuardBreakThreshold: number,
	PerfectParryBoost: number,
	Hitstop: number,
	AutoAimCone: number,
	TargetRange: number,
	ProjectileSpeed: number,
	StaminaMax: number,
	UltimateMax: number,
}
export type UISettings = {
	ThemeColor: Color3,
	AccentColor: Color3,
	BarBG: Color3,
	BarFG: Color3,
	Font: Enum.Font,
	AnimTime: number,
}
export type MenuSettings = {
	Title: string,
	Subtitle: string,
}
export type SettingsType = {
	Physics: PhysicsSettings,
	Animation: AnimationSettings,
	Combat: CombatSettings,
	UI: UISettings,
	Menu: MenuSettings,
}

export type HumanoidHandlerType = {
	Character: Model,
	Root: BasePart,
	Settings: SettingsType,
	Velocity: Vector3,
	OnGround: boolean,
	Health: number,
	MaxHealth: number,
	Stamina: number,
	Ultimate: number,
	Posture: number,
	Motors: {[string]: Motor6D},
	Destroyed: boolean,
	applyDamage: (self: HumanoidHandlerType, amount: number) -> (),
	heal: (self: HumanoidHandlerType, amount: number) -> (),
	addUltimate: (self: HumanoidHandlerType, value: number) -> (),
	addPosture: (self: HumanoidHandlerType, value: number) -> (),
	regenPosture: (self: HumanoidHandlerType, dt: number) -> (),
	destroy: (self: HumanoidHandlerType) -> (),
}

export type PhysicsType = {
	H: HumanoidHandlerType,
	S: PhysicsSettings,
	Params: RaycastParams,
	DashT: number,
	WallNormal: Vector3?,
	groundCheck: (self: PhysicsType) -> RaycastResult?,
	wallCheck: (self: PhysicsType, dir: Vector3) -> RaycastResult?,
	dash: (self: PhysicsType) -> (),
	step: (self: PhysicsType, dt: number, inputDir: Vector3, jump: boolean, jujutsuMove: string?) -> (),
}

export type AnimType = {
	H: HumanoidHandlerType,
	S: AnimationSettings,
	Time: number,
	Active: {[string]: (dt: number) -> boolean},
	play: (self: AnimType, name: string, duration: number, sharp: number, pose: {[string]: CFrame}) -> (),
	update: (self: AnimType, dt: number, swayDir: Vector3) -> (),
}

export type CombatType = {
	H: HumanoidHandlerType,
	S: CombatSettings,
	LastParry: number,
	ParryActive: boolean,
	HitboxParams: RaycastParams,
	parry: (self: CombatType) -> (),
	applyPostureDamage: (self: CombatType, value: number) -> (),
	registerHit: (self: CombatType, targetChar: Model, damage: number, isTelegraphed: boolean) -> (),
	autoAimTarget: (self: CombatType, origin: Vector3, forward: Vector3) -> Model?,
	fireProjectile: (self: CombatType, origin: Vector3, mousePos: Vector3, speed: number, lifetime: number, radius: number) -> (),
}

export type VFXType = {
	bezierTrail: (self: VFXType, p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, duration: number, color: Color3) -> (),
	lightning: (self: VFXType, p0: Vector3, p1: Vector3, jag: number, segs: number, color: Color3, lifetime: number) -> (),
}

export type UILibType = {
	Player: Player,
	S: UISettings,
	Gui: ScreenGui,
	Loading: Frame,
	Menu: {Frame: Frame, Play: TextButton},
	HealthBar: {BG: Frame, FG: Frame, Label: TextLabel},
	UltBar: {BG: Frame, FG: Frame, Label: TextLabel},
	SkillSlots: {Container: Frame, Slots: {[number]: {Slot: Frame, Cooldown: Frame, Key: TextLabel, Ready: boolean}}},
	createLoading: (self: UILibType, parent: Instance, menuCfg: MenuSettings) -> Frame,
	createMenu: (self: UILibType, parent: Instance, menuCfg: MenuSettings) -> {Frame: Frame, Play: TextButton},
	showLoading: (self: UILibType, show: boolean) -> (),
	showMenu: (self: UILibType, show: boolean) -> (),
	createBar: (self: UILibType, parent: Instance, pos: UDim2, size: UDim2, label: string) -> {BG: Frame, FG: Frame, Label: TextLabel},
	updateBar: (self: UILibType, bar: {BG: Frame, FG: Frame, Label: TextLabel}, ratio: number) -> (),
	createSkills: (self: UILibType, parent: Instance, count: number) -> {Container: Frame, Slots: {[number]: {Slot: Frame, Cooldown: Frame, Key: TextLabel, Ready: boolean}}},
	setCooldown: (self: UILibType, slotIndex: number, duration: number) -> (),
}

--// Math Library
local MathLib = {}
function MathLib.bezier3(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, t: number): Vector3
	local u = 1 - t; local tt = t * t; local uu = u * u
	return p0 * (uu * u) + p1 * (3 * uu * t) + p2 * (3 * u * tt) + p3 * (tt * t)
end

function MathLib.smooth5(t: number): number
	return t * t * t * (t * (6 * t - 15) + 10)
end

function MathLib.easingBlend(t: number, sharpness: number): number
	local s = math.clamp(sharpness, 0, 1)
	local lin = t
	local sin = 0.5 - 0.5 * math.cos(math.pi * t)
	local back = (1.70158 + 1.70158 * s)
	local easeOutBack = 1 + back * ((t - 1) ^ 3) + back * ((t - 1) ^ 2)
	return lin * (1 - s) + sin * (s * 0.5) + easeOutBack * (s * 0.5)
end

function MathLib.oscillate(t: number, f: number, a: number, ph: number?): number
	return a * math.sin(2 * math.pi * f * t + (ph or 0))
end

function MathLib.jitter3(seed: number, t: number, amp: number): Vector3
	return Vector3.new(
		math.noise(seed, t) * amp,
		math.noise(seed + 13.37, t * 0.9) * amp,
		math.noise(seed - 7.77, t * 1.1) * amp
	)
end

function MathLib.lightningPath(p0: Vector3, p1: Vector3, jag: number, segs: number, seed: number): {Vector3}
	local pts = {p0}; local dir = p1 - p0
	for i = 1, segs - 1 do
		local t = i / segs; local base = p0 + dir * t
		table.insert(pts, base + MathLib.jitter3(seed + i * 0.123, t * 10, jag))
	end
	table.insert(pts, p1); return pts
end

function MathLib.capsuleCast(origin: Vector3, target: Vector3, radius: number, steps: number, params: RaycastParams): {hit: RaycastResult?, point: Vector3?}
	local dir = target - origin; local len = dir.Magnitude
	if len <= 1e-6 then
		local r = workspace:Raycast(origin, Vector3.new(0, -radius, 0), params)
		return {hit = r, point = r and r.Position or origin}
	end
	local stepDir = dir.Unit; local stepLen = len / math.max(1, steps)
	for i = 0, steps do
		local p = origin + stepDir * (i * stepLen)
		local r = workspace:Raycast(p, stepDir * (radius + 0.1), params)
		if r then return {hit = r, point = r.Position} end
	end
	return {hit = nil, point = nil}
end

--// Humanoid Handler
local HumanoidHandler = {}
HumanoidHandler.__index = HumanoidHandler

function HumanoidHandler.new(character: Model, settings: SettingsType): HumanoidHandlerType
	local self = setmetatable({}, HumanoidHandler) :: any
	self.Character = character
	self.Root = character:WaitForChild("HumanoidRootPart") :: BasePart
	self.Settings = settings
	self.Velocity = Vector3.zero
	self.OnGround = false
	self.Health = 100
	self.MaxHealth = 100
	self.Stamina = settings.Combat.StaminaMax
	self.Ultimate = 0
	self.Posture = 0
	self.Motors = {}
	self.Destroyed = false

	for _, d in ipairs(character:GetDescendants()) do
		if d:IsA("Motor6D") then self.Motors[d.Name] = d end
	end

	local hum = character:FindFirstChildOfClass("Humanoid")
	if hum then
		hum:ChangeState(Enum.HumanoidStateType.Physics)
		hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	return self
end

function HumanoidHandler:applyDamage(amount: number)
	self.Health = math.clamp(self.Health - amount, 0, self.MaxHealth)
end

function HumanoidHandler:heal(amount: number)
	self.Health = math.clamp(self.Health + amount, 0, self.MaxHealth)
end

function HumanoidHandler:addUltimate(value: number)
	self.Ultimate = math.clamp(self.Ultimate + value, 0, self.Settings.Combat.UltimateMax)
end

function HumanoidHandler:addPosture(value: number)
	self.Posture = math.clamp(self.Posture + value, 0, self.Settings.Combat.PostureMax)
end

function HumanoidHandler:regenPosture(dt: number)
	self.Posture = math.max(0, self.Posture - self.Settings.Combat.PostureRegen * dt)
end

function HumanoidHandler:destroy()
	self.Destroyed = true
end

--// Physics Subsystem
local Physics = {}
Physics.__index = Physics

function Physics.new(handler: HumanoidHandlerType, settings: SettingsType): PhysicsType
	local self = setmetatable({}, Physics) :: any
	self.H = handler; self.S = settings.Physics
	self.Params = RaycastParams.new()
	self.Params.FilterDescendantsInstances = {handler.Character}
	self.DashT = 0; self.WallNormal = nil
	return self
end

function Physics:groundCheck() return workspace:Raycast(self.H.Root.Position, Vector3.new(0, - (self.S.StepHeight + 1.5), 0), self.Params) end

function Physics:wallCheck(dir: Vector3) return workspace:Raycast(self.H.Root.Position, dir.Unit * 3, self.Params) end

function Physics:dash() self.DashT = self.S.DashTime end

function Physics:step(dt: number, inputDir: Vector3, jump: boolean, jujutsuMove: string?)
	local root = self.H.Root; local vel = self.H.Velocity
	local ground = self:groundCheck(); self.H.OnGround = ground ~= nil

	local friction = self.H.OnGround and self.S.GroundFriction or self.S.AirFriction
	vel = vel - vel * math.clamp(friction * dt, 0, 1)

	local accel = self.H.OnGround and self.S.WalkAccel or self.S.AirAccel
	vel = vel + inputDir * accel * dt

	if self.DashT > 0 then
		local dir = inputDir.Magnitude > 0 and inputDir or root.CFrame.LookVector
		vel = dir.Unit * self.S.DashSpeed
		self.DashT -= dt
	end

	if jujutsuMove == "WallRun" then
		local hit = self:wallCheck(root.CFrame.LookVector)
		if hit then
			local tangent = (root.CFrame.LookVector - hit.Normal * root.CFrame.LookVector:Dot(hit.Normal)).Unit
			vel = tangent * self.S.WallRunSpeed + Vector3.new(0, 1.5, 0)
		end
	elseif jujutsuMove == "Climb" then
		local hit = self:wallCheck(root.CFrame.LookVector)
		if hit then vel = Vector3.new(vel.X, self.S.ClimbSpeed, vel.Z) end
	end

	if jump and self.H.OnGround then vel = Vector3.new(vel.X, self.S.JumpPower, vel.Z) end
	vel = vel + self.S.Gravity * dt

	local cast = MathLib.capsuleCast(root.Position, root.Position + vel * dt, 2, 4, self.Params)
	if cast.hit then
		vel = vel - cast.hit.Normal * vel:Dot(cast.hit.Normal)
		root.Position = (cast.point or root.Position) + cast.hit.Normal * 0.1
	else
		root.Position = root.Position + vel * dt
	end

	self.H.Velocity = vel
end

--// Procedural Animation Subsystem
local Anim = {}
Anim.__index = Anim

function Anim.new(handler: HumanoidHandlerType, settings: SettingsType): AnimType
	local self = setmetatable({}, Anim) :: any
	self.H = handler; self.S = settings.Animation; self.Time = 0; self.Active = {}
	return self
end

function Anim:play(name: string, duration: number, sharp: number, pose: {[string]: CFrame})
	local t0 = os.clock()
	self.Active[name] = function(dt: number)
		local elapsed = os.clock() - t0
		local alpha = math.clamp(elapsed / duration, 0, 1)
		local ease = MathLib.easingBlend(alpha, sharp)
		for motorName, targetCF in pairs(pose) do
			local motor = self.H.Motors[motorName]
			if motor then motor.C0 = motor.C0:Lerp(motor.C0 * targetCF, ease) end
		end
		return alpha >= 1
	end
end

function Anim:update(dt: number, swayDir: Vector3)
	self.Time += dt
	for name, fn in pairs(self.Active) do
		if fn(dt) then self.Active[name] = nil end
	end

	local sway = MathLib.oscillate(self.Time, self.S.SwayFrequency, self.S.SwayAmplitude)
	local root = self.H.Motors["RootJoint"]
	if root then root.C0 = root.C0 * CFrame.Angles(0, sway, 0) end
end

--// Combat Subsystem
local Combat = {}
Combat.__index = Combat

function Combat.new(handler: HumanoidHandlerType, settings: SettingsType): CombatType
	local self = setmetatable({}, Combat) :: any
	self.H = handler; self.S = settings.Combat; self.LastParry = 0; self.ParryActive = false
	self.HitboxParams = RaycastParams.new()
	self.HitboxParams.FilterDescendantsInstances = {handler.Character}
	return self
end

function Combat:parry()
	if os.clock() - self.LastParry < self.S.ParryCooldown then return end
	self.LastParry = os.clock(); self.ParryActive = true
	task.delay(self.S.ParryWindow, function() self.ParryActive = false end)
end

function Combat:applyPostureDamage(value: number)
	self.H:addPosture(value)
	if self.H.Posture >= self.S.PostureMax * self.S.GuardBreakThreshold then
		self.H.Posture = 0
		-- Guard break visual logic here
	end
end

function Combat:registerHit(targetChar: Model, damage: number, isTelegraphed: boolean)
	local parried = self.ParryActive and isTelegraphed
	local finalDamage = parried and 0 or damage
	if parried then self.H:addUltimate(10) end

	local hum = targetChar:FindFirstChildOfClass("Humanoid")
	if hum then hum:TakeDamage(finalDamage) end
end

function Combat:autoAimTarget(origin: Vector3, forward: Vector3)
	local best: Model? = nil; local maxDot = self.S.AutoAimCone
	for _, p in ipairs(Players:GetPlayers()) do
		if p.Character and p.Character ~= self.H.Character then
			local hrp = p.Character:FindFirstChild("HumanoidRootPart") :: BasePart?
			if hrp then
				local dir = (hrp.Position - origin).Unit
				local dot = forward:Dot(dir)
				if dot > maxDot then maxDot = dot; best = p.Character end
			end
		end
	end
	return best
end

function Combat:fireProjectile(origin: Vector3, mousePos: Vector3, speed: number, lifetime: number, radius: number)
	local p = Instance.new("Part")
	p.Size = Vector3.new(radius, radius, radius); p.Color = Color3.new(1,1,0); p.Anchored = true; p.CanCollide = false; p.Parent = workspace
	p.CFrame = CFrame.new(origin, mousePos)
	local start = os.clock()
	local conn; conn = RunService.Heartbeat:Connect(function(dt)
		if os.clock() - start > lifetime then p:Destroy(); conn:Disconnect(); return end
		p.CFrame *= CFrame.new(0, 0, -speed * dt)
	end)
end

--// Destruction Subsystem
local Destruction = {}
function Destruction.shatter(part: BasePart, shards: number)
	local pos = part.Position; local color = part.Color; local size = part.Size
	part:Destroy()
	for i = 1, shards do
		local s = Instance.new("Part")
		s.Size = size / math.sqrt(shards); s.Position = pos + MathLib.jitter3(i, 1, 1); s.Color = color; s.Parent = workspace
		Debris:AddItem(s, 2)
	end
end

--// VFX Subsystem
local VFX = {}
VFX.__index = VFX
function VFX.new(): VFXType return setmetatable({}, VFX) :: any end

function VFX:bezierTrail(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, duration: number, color: Color3)
	local attachment0 = Instance.new("Attachment", workspace.Terrain)
	local attachment1 = Instance.new("Attachment", workspace.Terrain)
	local trail = Instance.new("Trail"); trail.Color = ColorSequence.new(color); trail.Parent = workspace.Terrain
	trail.Attachment0 = attachment0; trail.Attachment1 = attachment1
	local start = os.clock()
	task.spawn(function()
		while os.clock() - start < duration do
			local t = (os.clock() - start) / duration
			local pos = MathLib.bezier3(p0, p1, p2, p3, t)
			attachment0.Position = pos; attachment1.Position = pos + Vector3.new(0, 1, 0)
			RunService.Heartbeat:Wait()
		end
		trail:Destroy(); attachment0:Destroy(); attachment1:Destroy()
	end)
end

function VFX:lightning(p0: Vector3, p1: Vector3, jag: number, segs: number, color: Color3, lifetime: number)
	local pts = MathLib.lightningPath(p0, p1, jag, segs, math.random(1, 1000))
	for i = 1, #pts - 1 do
		local p = Instance.new("Part")
		p.Anchored = true; p.CanCollide = false; p.Color = color; p.Material = Enum.Material.Neon
		p.Size = Vector3.new(0.2, 0.2, (pts[i+1] - pts[i]).Magnitude)
		p.CFrame = CFrame.new((pts[i] + pts[i+1])/2, pts[i+1]); p.Parent = workspace
		Debris:AddItem(p, lifetime)
	end
end

--// UI Subsystem
local UILib = {}
UILib.__index = UILib

function UILib.new(player: Player, settings: SettingsType): UILibType
	local self = setmetatable({}, UILib) :: any
	self.Player = player; self.S = settings.UI
	local gui = Instance.new("ScreenGui"); gui.Parent = player:WaitForChild("PlayerGui")
	self.Gui = gui
	return self
end

function UILib:createBar(parent: Instance, pos: UDim2, size: UDim2, label: string)
	local bg = Instance.new("Frame"); bg.BackgroundColor3 = self.S.BarBG; bg.Position = pos; bg.Size = size; bg.Parent = parent
	local fg = Instance.new("Frame"); fg.BackgroundColor3 = self.S.BarFG; fg.Size = UDim2.fromScale(1, 1); fg.Parent = bg
	local txt = Instance.new("TextLabel"); txt.Text = label; txt.Size = UDim2.fromScale(1, 1); txt.BackgroundTransparency = 1; txt.Parent = bg
	return {BG = bg, FG = fg, Label = txt}
end

function UILib:updateBar(bar: any, ratio: number)
	bar.FG:TweenSize(UDim2.fromScale(math.clamp(ratio, 0, 1), 1), "Out", "Quad", self.S.AnimTime, true)
end

--// Main Hybrid Module
local HybridModule = {}
HybridModule.__index = HybridModule

HybridModule.DefaultSettings = {
	Physics = { Gravity = Vector3.new(0, -196.2, 0), MaxSlope = 50, GroundFriction = 8, AirFriction = 0.5, StepHeight = 2, WalkAccel = 80, AirAccel = 40, JumpPower = 65, DashSpeed = 120, DashTime = 0.2, ClimbSpeed = 20, WallRunSpeed = 30 },
	Animation = { BlendSharpness = 0.6, SwayAmplitude = 0.05, SwayFrequency = 2, FootIK = false },
	Combat = { ParryWindow = 0.2, ParryCooldown = 0.8, PostureMax = 100, PostureRegen = 15, GuardBreakThreshold = 0.9, PerfectParryBoost = 1.5, Hitstop = 0.05, AutoAimCone = 0.8, TargetRange = 100, ProjectileSpeed = 200, StaminaMax = 100, UltimateMax = 100 },
	UI = { ThemeColor = Color3.fromRGB(255, 0, 0), AccentColor = Color3.fromRGB(255, 255, 255), BarBG = Color3.fromRGB(30, 30, 30), BarFG = Color3.fromRGB(200, 0, 0), Font = Enum.Font.GothamBold, AnimTime = 0.2 },
	Menu = { Title = "HYBRID SYSTEMS", Subtitle = "ADVANCED COMBAT ENGINE" }
}

function HybridModule.new(player: Player, character: Model, settings: SettingsType?)
	local self = setmetatable({}, HybridModule)
	local activeSettings = settings or HybridModule.DefaultSettings

	self.Player = player
	self.Character = character
	self.Handler = HumanoidHandler.new(character, activeSettings)
	self.Physics = Physics.new(self.Handler, activeSettings)
	self.Anim = Anim.new(self.Handler, activeSettings)
	self.Combat = Combat.new(self.Handler, activeSettings)
	self.VFX = VFX.new()
	self.UI = UILib.new(player, activeSettings)

	self._conn = RunService.Heartbeat:Connect(function(dt)
		if self.Handler.Destroyed then return end
		local moveDir = Vector3.zero
		self.Physics:step(dt, moveDir, false)
		self.Anim:update(dt, moveDir)
		self.Handler:regenPosture(dt)
	end)

	return self
end

function HybridModule:destroy()
	if self._conn then self._conn:Disconnect() end
	self.Handler:destroy()
	if self.UI.Gui then self.UI.Gui:Destroy() end
end

return HybridModule
